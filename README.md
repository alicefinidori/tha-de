# THA - DE - Banner Selection Web Application 

The goal of this project is to create a web page which serves banners for one of many websites owned by our client.

## Assumptions made for this exercise

- The web application is a read only application, i.e. it will not write to the source data. Indeed, this application is used to serve banners and not to update the logic with which the banners are served.
- The web application has a single endpoint which returns a single banner for a given ``campaign_id``. 
- The source data is expected to be relatively static, i.e. to be updated maybe daily or weekly because:
  - Campaigns and their associated banners are created or updated ad-hoc
  - Revenue generated by clicks for our client will be computed as a batch on a schedule and returned to us as static files during a maintenance window. 

## Architecture 

### Web application 

The web application has the following architecture

![web_app_architecture_with_s3.png](readme_images%2Fweb_app_architecture_with_s3.png)

A user connects to a lambda function via API Gateway, which in turn queries a Postgres Database on Amazon RDS containing the result data, and returns a banner_id. 

The lambda function then returns an image contained in a s3 bucket for the banner. 

### Data Loading

![data_loading_architecture.png](readme_images%2Fdata_loading_architecture.png)

To update the source data, an administrator or process updates the files in an S3 bucket, which triggers a lambda function, which in turn will update the Postgres Database on Amazon RDS.

As mentioned in the initial assumptions, this is expected to happen at most daily during a maintenance window. 

In this exercise, for simplicity and time constraints (to be able to quickly explore the raw data and test transformations), we will be following an ELT process, where all the raw data is loaded to the final data Store, then transformed in the same data store.
Since the raw data is not required by the web application, a future enhancement could be to remove the raw data from the final data store and store is simply as intermediary csv or in a data warehouse.

We will also not be catering for schema changes in this exercise. 

## Data Modelling

### Source Data

The source data is split into 4 data sets, representing the 4 quarters of an hour i.e. a visit to the website on any hour will direct to a different dataset depending on the minute of the hour: 

| Minute | Dataset| 
| ------- | ------- | 
| 00 <= m < 15 | dataset 1 | 
| 15 <= m < 30 |  dataset 2 | 
| 30 <= m < 45 | dataset 3 | 
| 45 <= m < 00 | dataset 4 | 

 Each data set contains the same following files: 
- ``impressions.csv``: File containing impressions of different banners a campaign i.e. a record for each time a user saw a banner within a given campaign.
- ``clicks.csv``: File containing clicks on different banners within a campaign i.e. a record for each time a user clicked on a banner within a given campaign.
- ``conversions.csv``: File containing conversions for each converted click i.e. a record for each time a click generated revenue, and the amount of revenue generated.

### Snowflake schema

For this project, with normalising the data, the ERD diagram can be as follows:
![erd.png](readme_images%2Ferd.png)
With the following tables: 
- campaign_banner

This table is the reference of what banner belongs to what campaign within each dataset. The ``dataset`` field is added to reference which dataset this campaign belongs to.
This is the only table that can not be directly associated with one of the input csv files. Because this reference data does not exist, it can be inferred from the ``impressions.csv`` files.

- impressions

The list of impressions for each campaign_banner. The ``impressions_id`` can be auto generated for each record in the ``impresions.csv`` file.

- clicks: 

The list of clicks for each campaign_banner. Obtained from the ``clicks.csv`` and extracting the ``campaign_banner_id`` from the ``campaign_banner`` table. 

- conversions

The list of clicks and revenue for each campaign_banner. Directly generated from the ``conversions.csv`` file.


### Business Rules

For each campaign, our web page wants to select at random a banner within a list of banners with the following business rules: 

|  X definition | Definition/Requirement | 
| ------ |--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| 
| X  | the number of banners with conversions within a campaign                                                                                                                                                                       | 
| X >= 10 | Show the Top 10 banners based on revenue within that campaign                                                                                                                                                                  | 
| X in range(5,10) | Show the Top X banners based on revenue within that campaign                                                                                                                                                                   | 
| X in range(1,5) | Your collection of banners should consist of 5 banners, containing: The top x banners based on revenue within that campaign and Banners with the most clicks within that campaign to make up a collection of 5 unique banners. | 
| X == 0 | Show the Top 5 banners based on clicks. If the number of banners with clicks is less than 5 within that campaign, then you should add random banners to make up a collection of 5 unique banners.                              | 


To obtain this list, we will create the following two tables:

- conversions_and_clicks_agg: 

![conversions_and_clicks_agg.png](readme_images%2Fconversions_and_clicks_agg.png)

For each campaign_banner (i.e. id, campaign_id, banner_id combination), calculate total revenue and click counts.

- top_banners

![top_banners.png](readme_images%2Ftop_banners.png)

For each campaign_banner (i.e. id, campaign_id, banner_id combination), show between 5 and 10 banners depending on the business rules defined above. 
The web page will select for each campaign id a random banner within this list to serve to our end user. 



## Load testing


## Enhancements


1. Ensure a unique visitor never sees the same banner twice in a row. 

In the current implementation, the web page will select a random banner thanks to the use of the ``random()`` method in Postgres. 
We will assume for the sake of this exercise that it is highly unlikely that for a given user, the same banner will be returned twice.

An enhancement of this app would be to ensure a user does not see the same banner twice by storing session data for all API calls: 
- when a given user opens a session, each time an API call is made, the last returned banner is stored in the session data as ``previous_banner_id`` 
- the following time a user queries the database explicitly excluding ``previous_banner_id``

2. Continuous updates to the source data

An initial assumption for this project is that the source data will be updated on a schedule. 

If this requirement changes, we could introduce a streaming architecture to continuously update the ``impressions`` and ``conversions`` data sources.
This can be done by changing the Data Loading lambda function to be triggered by an event in AWS Kinesis or Confluent Kafka.

3. Raw data storage

In this exercise, for simplicity and time constraints (to be able to quickly explore the raw data and test transformations), we will be following an ELT process, where all the raw data is loaded to the final data Store, then transformed in the same data store.
Since the raw data is not required by the web application, a future enhancement could be to remove the raw data from the final data store and store is simply as intermediary csv or in a data warehouse.

Another improvement would be to cater for schema changes in the raw data. 

4. CI/CD

All the resources and code were manually updated for this project. Including CI/CD will make it more maintainable.

5. Security

For the sake of this exercise, security was not a main concern. For a production application, the necessary precautions will need to be taken for networking and API Gateway authorizations to make sure this application is secure. 